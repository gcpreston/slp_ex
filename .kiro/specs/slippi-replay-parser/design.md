# Design Document

## Overview

The SlpEx library provides a comprehensive Slippi replay parser for Elixir that processes .slp files generated by Project Slippi for Super Smash Bros. Melee. The design emphasizes modularity, performance, and extensibility to support both file-based parsing and future streaming protocol integration.

The parser extracts structured game data including match metadata, player information, frame-by-frame game state, and computed statistics while providing robust error handling for various file formats and versions.

## Architecture

### High-Level Architecture

The system follows a layered architecture with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────┐
│                    Public API Layer                         │
│                      (SlpEx)                                │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                  Processing Layer                           │
│            (SlpEx.Parser, SlpEx.Stats)                      │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   Data Layer                                │
│              (SlpEx.Data.*)                                 │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                  Utility Layer                              │
│               (SlpEx.Utils)                                 │
└─────────────────────────────────────────────────────────────┘
```

### Design Principles

1. **Modularity**: Separate binary parsing logic from I/O operations to enable reuse for streaming
2. **Performance**: Use streaming binary parsing to minimize memory usage
3. **Robustness**: Comprehensive error handling with graceful degradation
4. **Extensibility**: Support multiple .slp format versions and future enhancements

## Components and Interfaces

### SlpEx (Main Module)

**Purpose**: Public API entry point providing high-level functions for parsing .slp files.

**Key Functions**:
- `parse_file/1` - Parse a .slp file from filesystem
- `parse_file/2` - Parse with options (selective parsing, lazy loading)
- `parse_binary/1` - Parse .slp data from binary (for streaming support)

**Design Rationale**: Single entry point simplifies usage while options parameter allows for performance optimization.

### SlpEx.Parser

**Purpose**: Core binary parsing logic that processes .slp file structure.

**Submodules**:
- `SlpEx.Parser.Header` - File header validation, version detection, and game setting processing
- `SlpEx.Parser.Frames` - Frame-by-frame data processing
- `SlpEx.Parser.Events` - Game event parsing and processing
- `SlpEx.Parser.Metadata` - Game metadata and player information extraction

**Key Functions**:
- `parse_header/1` - Validate file format and extract version and game settings
- `parse_frames/1` - Process frame data with rollback handling
- `parse_events/1` - Extract game events and state changes
- `parse_metadata/1` - Extract player data and recording metadata

**Design Rationale**: Modular parsing allows for selective data extraction and reuse across file and streaming contexts.

### SlpEx.Data

**Purpose**: Data structures and schemas for representing parsed .slp data.

**Submodules**:
- `SlpEx.Data.Game` - Overall game/match representation
- `SlpEx.Data.Settings` - Settings information, such as replay version, player info, and fix list
- `SlpEx.Data.Frame` - Frame data structures
- `SlpEx.Data.Metadata` - Game metadata structures
- `SlpEx.Data.Statistics` - High-level end-game stats, such as number of stocks remaining, number of openings, and openings per kill

**Key Structures**:
```elixir
%SlpEx.Data.Game{
  metadata: %SlpEx.Data.Metadata{},
  settings: %SlpEx.Data.Settings{},
  frames: [%SlpEx.Data.Frame{}],
  statistics: %SlpEx.Data.Statistics{},
  version: String.t(),
  errors: [String.t()]
}
```

**Design Rationale**: Structured data types provide clear contracts and enable pattern matching for data processing.

### SlpEx.Stats

**Purpose**: Statistics computation and derived data calculation.

**Key Functions**:
- `compute_basic_stats/1` - Match duration, stocks, damage
- `compute_player_metrics/1` - Action counts, movement data
- `identify_events/1` - Kills, deaths, significant state changes
- `compute_interactions/1` - Player interaction statistics

**Design Rationale**: Separate statistics module allows for optional computation and extensibility of metrics.

### SlpEx.Utils

**Purpose**: Utility functions for binary processing, validation, and common operations.

**Key Functions**:
- `validate_file_format/1` - File format validation
- `handle_version_differences/2` - Version compatibility handling
- `stream_binary_chunks/2` - Memory-efficient binary processing
- `sanitize_data/1` - Data cleaning and validation

## Data Models

### Core Data Structures

#### Game Structure
```elixir
%SlpEx.Data.Game{
  metadata: %SlpEx.Data.Metadata{},
  settings: %SlpEx.Data.Settings{},
  frames: [%SlpEx.Data.Frame{}],
  statistics: %SlpEx.Data.Statistics{},
  version: String.t(),
  parsing_errors: [String.t()]
}
```

#### Metadata Structure
```elixir
%SlpEx.Data.Metadata{
  start_at: DateTime.t(),
  last_frame: integer(),
  played_on: atom(),
  console_nick: String.t()
}
```

#### Settings Structure
```elixir
%SlpEx.Data.Settings{
  version: String.t(),
  players: [
    %SlpEx.Data.Player{
      port: integer(),
      character: atom(),
      tag: String.t() | nil,
      player_type: atom(),
      controller_fix: String.t()
    }
  ],
  is_teams: boolean(),
  item_spawn_behavior: integer(),
  self_destruct_score_value: integer(),
  stage_id: integer(),
  game_timer: integer()
}
```

#### Frame Data Structure
```elixir
%SlpEx.Data.Frame{
  index: integer(),
  pre_frame: %{
    player_states: map(),
    inputs: map()
  },
  post_frame: %{
    player_states: map(),
    positions: map(),
    velocities: map(),
    animation_states: map()
  },
  is_rollback: boolean()
}
```

#### Statistics Structure
```elixir
%SlpEx.Data.Statistics{
  match_duration: integer(),
  total_frames: integer(),
  player_stats: %{
    stocks_remaining: map(),
    damage_dealt: map(),
    damage_taken: map(),
    action_counts: map(),
    kill_count: map(),
    death_count: map()
  },
  game_events: [
    %{type: atom(), frame: integer(), data: map()}
  ]
}
```

### Version Compatibility

The parser supports multiple .slp format versions through a version-aware parsing strategy:

- Version detection from file header
- Version-specific parsing logic for format differences
- Graceful degradation for unsupported features
- Clear error reporting for incompatible versions

## Error Handling

### Error Categories

1. **File Format Errors**: Invalid .slp files, corrupted headers
2. **Version Compatibility Errors**: Unsupported .slp versions
3. **Parsing Errors**: Corrupted frame data, invalid binary structures
4. **Validation Errors**: Inconsistent game state, invalid player data

### Error Handling Strategy

```elixir
# Successful parsing with warnings
{:ok, %SlpEx.Data.Game{parsing_errors: ["Frame 1234 corrupted, skipped"]}}

# Partial parsing success
{:ok, %SlpEx.Data.Game{frames: [], parsing_errors: ["Frame data corrupted"]}}

# Complete parsing failure
{:error, {:invalid_format, "Not a valid .slp file"}}
{:error, {:unsupported_version, "Version 4.0 not supported"}}
```

**Design Rationale**: Graceful degradation allows extraction of available data even when some sections fail, maximizing utility of partially corrupted files.

## Testing Strategy

### Unit Testing

- **Parser Components**: Test each parsing module independently with known binary data
- **Data Structures**: Validate data structure creation and validation
- **Statistics**: Test computation accuracy with known game scenarios
- **Error Handling**: Test error conditions and recovery mechanisms

### Integration Testing

- **End-to-End Parsing**: Test complete .slp file parsing workflows
- **Version Compatibility**: Test parsing across different .slp versions
- **Performance**: Test memory usage and parsing speed with large files
- **Concurrent Processing**: Test multiple file parsing scenarios

### Test Data Strategy

- **Sample Files**: Curated .slp files representing different game scenarios
- **Synthetic Data**: Generated binary data for edge case testing
- **Corrupted Files**: Intentionally corrupted files for error handling tests
- **Version Samples**: Files from different Slippi versions

### Property-Based Testing

Use property-based testing for:
- Binary parsing round-trip consistency
- Statistics computation accuracy
- Error handling completeness
- Performance characteristics

**Design Rationale**: Comprehensive testing strategy ensures reliability across diverse .slp files and usage scenarios while maintaining performance requirements.

## Performance Considerations

### Memory Optimization

- **Streaming Parsing**: Process binary data in chunks to minimize memory footprint
- **Lazy Loading**: Optional lazy loading of frame data for large files
- **Selective Parsing**: Allow parsing of specific data sections only

### Concurrency Support

- **Process Isolation**: Each file parsing operation runs in separate process
- **Concurrent Batch Processing**: Support for parsing multiple files simultaneously
- **Resource Management**: Proper cleanup and resource management for large operations

### Caching Strategy

- **Parsed Data Caching**: Optional caching of parsed results for repeated access
- **Metadata Caching**: Fast access to frequently requested metadata without full parsing

**Design Rationale**: Performance optimizations enable processing of large .slp files and batch operations while maintaining system responsiveness.